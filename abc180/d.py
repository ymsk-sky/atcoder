"""
*A or +B
*Aを何回かした後に+Bをするのがよい
+Bの後*Aをすると、Z -> Z+B -> A(Z+B)= AZ+AB
これは*Aした後に+BをA回したのと同じ
Z -> AZ -> AZ+B -> AZ+2B -> AZ+3B -> ... -> AZ+AB
よって*Aが先、+Bが後となる
*AをO(log)で計算後+BをO(1)で計算する
"""
# x: 強さ, y: 強さの上限, a: +A & 経験値+1, b: *b & 経験値+1
x,y,a,b=map(int,input().split())
exp=0  # 経験値
while a*x<=x+b and a*x<y:
    # 先に*Aをできるだけ行なう
    x*=a
    exp+=1
print(exp+(y-1-x)//b)
"""(y-1-x)//bについて
y-1-x: 強さ上限から現在の強さを引いた値(-1は「未満」のため)
この値をbで割る(小数点切り下げ)ことで+Bの回数を数える
"""
